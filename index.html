<!doctype html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" >
  <script src="https://distill.pub/template.v2.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css"
    integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0"
    crossorigin="anonymous">
  <script
    src="https://code.jquery.com/jquery-3.2.1.min.js"
    integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
    crossorigin="anonymous"></script>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <style>
   .column-to-row-captioned {
      width: 100%;
      margin-top: 0px;
      margin-bottom: 20px;
      display:grid;
      grid-auto-rows: min-content;
      grid-column-gap:30px;
      grid-row-gap: 30px;
      grid-auto-flow: row;
   }

   @media(min-width: 512px) {
     .column-to-row-captioned {
        grid-auto-columns: 1fr;
        grid-auto-flow: column;
      }
   }

   .hmm-grid {
      display: grid;
      grid-template-columns: 18% 18% 55%;
      grid-column: page;
      grid-column-gap: 5%;
      max-width: 750px;
      margin-bottom:20px;
   }
   figure {
      margin-left: auto;
      margin-right: auto;
      width: 704px;
    }
    .figure-math {
      margin-left: 1em;
    }
  </style>
</script>
</head>

</body>
<distill-header></distill-header>
<d-front-matter>
  <script id="distill-front-matter" type="text/json">{
    "title": "Sequence Modeling with CTC",
    "description": "A visual guide to CTC, an algorithm used to train deep neural networks in speech recognition, handwriting recognition and other sequence problems.",
    "authors": [
      {"author" : "Awni Hannun",
       "authorURL" : "http://stanford.edu/~awni/",
       "affiliation": "Stanford University",
       "affiliationURL" : "http://cs.stanford.edu/"}
    ]
  }</script>
</d-front-matter>

<d-title>
<h1>Sequence Modeling with CTC</h1>
<p>A visual guide to CTC, an algorithm used to train deep neural networks in
speech recognition, handwriting recognition and other sequence problems.</p>
<figure style="width:100%;grid-column:page;display:grid;grid-auto-flow:row">
  <link rel="stylesheet" type="text/css" href="assets/collapse_ctc.css">
  <div style="padding-bottom:3%">
  How CTC collapsing works
  </div>
  <div style="display:grid;grid-template-columns:12% 76% 12%;margin-bottom:1%;">
    <figcaption class="caption_text" style="padding-top:10%;">
    For an input,<br/> like speech
    </figcaption>
    <img src="assets/speech.svg" style="width:98%"/>
  </div>
  <div style="display:grid;grid-template-columns:12% 76% 12%">
    <div>
    <figcaption class="caption_text" style="padding-top:3%;">
    Predict a <br/>sequence of <br/>tokens
    </figcaption>
    </div>
    <div spellcheck="false" autocorrect="off" contenteditable="true" id="alignment"></div>
    <div>
    <figcaption class="return_text" style="line-height:180%;padding-top:.5vw">
    Use <span id="return_botton">return</span> to<br/> input a blank <d-math>(\epsilon)</d-math>
    </figcaption>
    </div>
  </div>
  <div style="display:grid;grid-template-columns:12% 76% 12%">
    <div>
      <figcaption class="caption_text" style="padding-top:35%;">Merge repeats,<br />drop <d-math>\epsilon</d-math></figcaption>
      <figcaption class="caption_text" style="padding-top:47%;">Final output</figcaption>
    </div>
    <div>
   <svg id="collapse_output" style="width:94.5%;padding-left:1.15vw" viewBox="0 0 670 170">
    <g id="merge_g" transform="translate(0, 40)">
      <rect fill="#f0f0f0" width="40" height="40" />
      <rect fill="#f0f0f0" x="42" width="40" height="40" />
      <rect fill="#f0f0f0" x="84" width="40" height="40" />
      <rect fill="#f0f0f0" x="126" width="40" height="40" />
      <rect fill="#f0f0f0" x="168" width="40" height="40" />
      <rect fill="#f0f0f0" x="210" width="40" height="40" />
      <rect fill="#f0f0f0" x="252" width="40" height="40" />
      <rect fill="#f0f0f0" x="294" width="40" height="40" />
      <rect fill="#f0f0f0" x="336" width="40" height="40" />
      <rect fill="#f0f0f0" x="378" width="40" height="40" />
      <rect fill="#f0f0f0" x="420" width="40" height="40" />
      <rect fill="#f0f0f0" x="462" width="40" height="40" />
      <rect fill="#f0f0f0" x="504" width="40" height="40" />
      <rect fill="#f0f0f0" x="546" width="40" height="40" />
      <rect fill="#f0f0f0" x="588" width="40" height="40" />
      <rect fill="#f0f0f0" x="630" width="40" height="40" />
    </g>
    <g id="final_g" transform="translate(0, 120)">
      <rect fill="#f0f0f0" width="40" height="40" />
      <rect fill="#f0f0f0" x="42" width="40" height="40" />
      <rect fill="#f0f0f0" x="84" width="40" height="40" />
      <rect fill="#f0f0f0" x="126" width="40" height="40" />
      <rect fill="#f0f0f0" x="168" width="40" height="40" />
      <rect fill="#f0f0f0" x="210" width="40" height="40" />
      <rect fill="#f0f0f0" x="252" width="40" height="40" />
      <rect fill="#f0f0f0" x="294" width="40" height="40" />
      <rect fill="#f0f0f0" x="336" width="40" height="40" />
      <rect fill="#f0f0f0" x="378" width="40" height="40" />
      <rect fill="#f0f0f0" x="420" width="40" height="40" />
      <rect fill="#f0f0f0" x="462" width="40" height="40" />
      <rect fill="#f0f0f0" x="504" width="40" height="40" />
      <rect fill="#f0f0f0" x="546" width="40" height="40" />
      <rect fill="#f0f0f0" x="588" width="40" height="40" />
      <rect fill="#f0f0f0" x="630" width="40" height="40" />
    </g>
    <g id="paths"></g>
  </svg>
    </div>
  </div>
</figure>
<script src="assets/collapse_ctc.js"></script>
</d-title>

<d-article>
<p>Consider speech recognition. We have a dataset of audio clips and
corresponding transcripts. Unfortunately, we don't know how the characters in
the transcript align to the audio. This makes training a speech recognizer
harder than it might at first seem.</p>

<p>Without this alignment, the simple approaches aren't available to us. We
could devise a rule like "one character corresponds to ten inputs". But
people's rates of speech vary, so this type of rule can always be broken.
Another alternative is to hand-align each character to its location in the
audio. From a modeling standpoint this works well &mdash; we'd know the ground truth
for each input time-step. However, for any reasonably sized dataset this is
prohibitively time consuming.</p>

<p>This problem doesn't just turn up in speech recognition. We see it in many
other places. Handwriting recognition from images or sequences of pen strokes
is one example. Action labelling in videos is another.</p>

<figure class="column-to-row-captioned">
  <div>
    <img src="assets/handwriting_recognition.svg" />
    <figcaption>
    <strong>Handwriting recognition:</strong> The input can be
    <d-math>(x,y)</d-math> coordinates of a pen stroke or 
    pixels in an image.
    </figcaption>
  </div>
  <div>
    <img src="assets/speech_recognition.svg" />
    <figcaption>
    <strong>Speech recognition:</strong> The input can be a spectrogram or some
    other frequency based feature extractor.
    </figcaption>
  </div>
</figure>

<p>Connectionist Temporal Classification (CTC) is a way to get around not
knowing the alignment between the input and the output. As we'll see, it's
especially well suited to applications like speech and handwriting
recognition.</p>

<hr />

<p>To be a bit more formal, let's consider mapping input sequences
<d-math>X = [x_1, x_2, \ldots, x_T]</d-math>, such as audio, to corresponding output
sequences <d-math>Y = [y_1, y_2, \ldots, y_U]</d-math>, such as transcripts.
We want to find an accurate mapping from <d-math>X</d-math>'s to <d-math>Y</d-math>'s.</p>

<p>There are challenges which get in the way of us
using simpler supervised learning algorithms. In particular:</p>
<ul>
  <li>Both <d-math>X</d-math> and <d-math>Y</d-math>
    can vary in length.</li>
  <li>The ratio of the lengths of <d-math>X</d-math> and <d-math>Y</d-math>
    can vary.</li>
  <li>We don't have an accurate alignment (correspondence of the elements) of
  <d-math>X</d-math> and <d-math>Y.</d-math></li>
</ul>

<p>The CTC algorithm overcomes these challenges. For a given <d-math>X</d-math>
it gives us an output distribution over all possible <d-math>Y</d-math>'s. We
can use this distribution either to <em>infer</em> a likely output or to asses
the <em>probability</em> of a given output.</p>

<p>Not all ways of computing the loss function and performing inference are
tractable. We'll require that CTC do both of these efficiently.</p>

<p><strong>Loss Function:</strong> For a given input, we'd like to train our
model to maximize the probability it assigns to the right answer.  To do this,
we'll need to efficiently compute the conditional probability
<d-math>p(Y \mid X).</d-math> The function <d-math>p(Y \mid X)</d-math> should
also be differentiable, so we can use gradient descent.</p>

<p><strong>Inference:</strong> Naturally, after we've trained the model, we
want to use it to infer a likely <d-math>Y</d-math> given an <d-math>X.</d-math>
This means solving 

<d-math block>
  Y^* \enspace =\enspace {\mathop{\text{argmax}}\limits_{Y}} \enspace p(Y \mid X).
</d-math>

Ideally <d-math>Y^*</d-math> can be found efficiently. With CTC we'll settle
for an approximate solution that's not too expensive to find.</p>

<hr />

<h2 id="the-algorithm">The Algorithm</h2>

<p>The CTC algorithm can assign a probability for any <d-math>Y</d-math>
given an <d-math>X.</d-math> The key to computing this probability is how CTC
thinks about alignments between inputs and outputs. We'll start by looking at
these alignments and then show how to use them to compute the loss function and
perform inference.</p>

<h3 id="the-alignment">Alignment</h3>

<p>The CTC algorithm is <em>alignment-free</em> &mdash; it doesn't require an
alignment between the input and the output. However, to get the probability of
an output given an input, CTC works by summing over the probability of all
possible alignments between the two. We need to understand what these
alignments are in order to understand how the loss function is ultimately
calculated.</p>

<p>To motivate the specific form of the CTC alignments, first consider a naive
approach. Let’s use an example. Assume the input has length six and <d-math>Y
=</d-math> [c, a, t]. One way to align <d-math>X</d-math> and <d-math>Y</d-math>
is to have a character for each input step and collapse repeats.</p>

<figure style="width:100%;margin-top:0px;margin-bottom:20px;">
  <div style="display:grid;grid-template-columns:25% 75%;max-width:350px;margin-left:auto;margin-right:auto">
  <figcaption>
    <div style="padding-top:10%;">input (<d-math>X</d-math>)</div>
    <div style="padding-top:45%;">alignment</div>
    <div style="padding-top:45%;">output (<d-math>Y</d-math>)</div>
  </figcaption>
  <div style="padding-left:20%;">
    <img src="assets/naive_alignment.svg" style="width:100%" />
  </div>
  </div>
</figure>

<p>This approach has two problems.</p>
<ul>
  <li>
    Often, it doesn't make sense to force every input step to align to
    some output. In speech recognition, for example, the input can have stretches
    of silence with no corresponding output.
  </li>

  <li>
    We have no way to produce outputs with multiple characters in a row.
    Consider the alignment [h, h, e, l, l, l, o]. Collapsing repeats will
    produce "helo" instead of "hello".
  </li>
</ul>

<p>To get around these problems, CTC introduces a new token to the set of
allowed outputs. This new token is sometimes called the <em>blank</em> token. We’ll
refer to it here as <d-math>\epsilon.</d-math> The
<d-math>\epsilon</d-math> token doesn't correspond to anything and is simply
removed from the output.</p>

<p>The alignments allowed by CTC are the same length as the input. We allow any
alignment which maps to <d-math>Y</d-math> after merging repeats and removing
<d-math>\epsilon</d-math> tokens:</p>

<figure style="width:100%;margin-top:0px;">
  <div style="margin-left:auto;margin-right:auto;max-width:500px;display:grid;grid-template-columns:30% 70%">
    <figcaption>
    <div style="padding-top:20%;">
      First, merge repeat characters.
    </div>
    <div style="padding-top:15%;">
      Then, remove any <d-math>\epsilon</d-math> tokens.
    </div>
    <div style="padding-top:15%;">
      The remaining characters are the output.
    </div>
    </figcaption>
    <img src="assets/ctc_alignment_steps.svg" />
  </div>
</figure>

<p>If <d-math>Y</d-math> has two of the same character in a row, then a valid 
alignment must have an <d-math>\epsilon</d-math> between them. With this rule
in place, we can differentiate between alignments of [h, e, l, l, o] and
[h, e, l, o].</p>

<p>Let's go back to the output [c, a, t] with an input of length six. Here are
a few more examples of valid and invalid alignments.</p>

<figure style="width:100%;margin-top:0px;">
  <div style="margin-left:auto;margin-right:auto;max-width:550px">
    <img src="assets/valid_invalid_alignments.svg" />
  </div>
</figure>


<p>The CTC alignment has a few notable properties. First, the allowed
alignments between <d-math>X</d-math> and <d-math>Y</d-math> are monotonic.
If we advance to the next input, we can keep the corresponding output the
same or advance to the next one. A second property is that the alignment of
<d-math>X</d-math> to <d-math>Y</d-math> is many-to-one. One or more input
elements can align to a single output element but not vice-versa. This implies
a third property: the length of <d-math>Y</d-math> cannot be greater than the
length of <d-math>X.</d-math></p>

<h3 id="loss-function">Loss Function</h3>

<p>The CTC alignments give us a natural way to go from probabilities at each
time-step to the probability of an output sequence.</p>

<figure style="margin-top:10px;width:100%;">
  <div style="margin-left:auto;margin-right:auto;max-width:600px">
    <img src="assets/full_collapse_from_audio.svg" />
  </div>
</figure>


<p style="margin-bottom:0px;">To be precise, the CTC objective
for a single <d-math>(X, Y)</d-math> pair is:</p>

<figure class="figure-math" style="width:100%;margin-top:0px;">
  <div style="display:grid;grid-template-rows:50% 50%">
  <div style="display:grid;grid-template-columns:20% 20% 30%;grid-column-gap:5%">
    <div style="line-height:75px;min-width:125px;">
      <d-math block>p(Y \mid X) \;\; =</d-math>
    </div>
    <div style="line-height:75px;">
      <d-math block>\sum_{A \in \mathcal{A}_{X,Y}}</d-math>
    </div>
    <div style="line-height:75px;">
      <d-math block>\prod_{t=1}^T \; p_t(a_t \mid X)</d-math>
    </div>
  </div>
  <div style="display:grid;grid-template-columns:20% 20% 30%;grid-column-gap:5%">
    <figcaption>
    The CTC conditional <strong>probability</strong>
    </figcaption>
    <figcaption>
    <strong>marginalizes</strong> over the set of valid alignments 
    </figcaption>
    <figcaption>
    computing the <strong>probability</strong> for a single alignment step-by-step.
    </figcaption>
  </div>
  </div>
</figure>

<p>Models trained with CTC typically use a recurrent neural network (RNN) to
estimate the per time-step probabilities, <d-math>p_t(a_t \mid X).</d-math>
The RNN works well here since it accounts for context in the input, but we're
free to use any learning algorithm which produces a distribution over output
classes given a fixed-size slice of the input.</p>

<p>If we aren't careful, the CTC loss can be very expensive to compute. We
could try the straightforward approach and compute the score for each alignment
summing them all up as we go. The problem is there can be a massive number of
alignments.
<d-footnote>
  For a <d-math>Y</d-math> of length <d-math>U</d-math> without any repeat
  characters and an <d-math>X</d-math> of length <d-math>T</d-math> the size
  of the set is <d-math>{T + U \choose T - U}.</d-math> For <d-math>T=100</d-math> and
  <d-math>U=50</d-math> this number is almost <d-math>10^{40}.</d-math>
</d-footnote>
For most problems this would be too slow.</p>

<p>Thankfully, we can compute the loss much faster with a dynamic programming
algorithm. The key insight is that if two alignments have reached the same
output at the same step, then we can merge them.</p>

<figure class="column-to-row-captioned">
  <div>
    <img style="max-width:350px;" src="assets/all_alignments.svg"/>
    <figcaption>
    Summing over all alignments can be very expensive.
    </figcaption>
  </div>
  <div>
    <img style="max-width:350px;" src="assets/merged_alignments.svg"/>
    <figcaption>
    Dynamic programming merges alignments, so it's much faster.
    </figcaption>
  </div>
</figure>

<p>Since we can have an <d-math>\epsilon</d-math> before or after any token in
<d-math>Y</d-math>, it's easier to describe the algorithm
using a sequence which includes them. We'll work with the sequence
<d-math block>
Z \enspace =\enspace [\epsilon, ~y_1, ~\epsilon, ~y_2,~ \ldots, ~\epsilon, ~y_U, ~\epsilon]
</d-math>
which is <d-math>Y</d-math> with an <d-math>\epsilon</d-math> at
the beginning, end, and between every character.</p>

<p>Let's let <d-math>\alpha</d-math> be the score of the merged alignments at a
given node. More precisely, <d-math>\alpha_{s, t}</d-math> is the CTC score of
the subsequence <d-math>Z_{1:s}</d-math> after <d-math>t</d-math> input steps.
As we'll see, we'll compute the final CTC score, <d-math>P(Y \mid X)</d-math>,
from the <d-math>\alpha</d-math>'s at the last time-step. As long as we know
the values of <d-math>\alpha</d-math> at the previous time-step, we can compute
<d-math>\alpha_{s, t}.</d-math> There are two cases.</p>

<p><strong>Case 1:</strong></p>

<div>
<figure style="width:165px;float:right;margin-top:0px;margin-bottom:10px; margin-left:12%;">
  <img src="assets/cost_no_skip.svg" />
</figure>

<p>In this case, we can't jump over <d-math>z_{s-1}</d-math>, the previous
token in <d-math>Z.</d-math> The first reason is that the previous token can
be an element of <d-math>Y</d-math>, and we can't skip elements of
<d-math>Y.</d-math> Since every element of <d-math>Y</d-math> in
<d-math>Z</d-math> is followed by an <d-math>\epsilon</d-math>, we can
identify this when <d-math> z_{s} = \epsilon.</d-math> The second reason is
that we must have an <d-math>\epsilon</d-math> between repeat characters in
<d-math>Y.</d-math>  We can identify this when
<d-math>z_s = z_{s-2}.</d-math></p>
</div>

<p>To ensure we don't skip <d-math>z_{s-1}</d-math>, we can either be there
at the previous time-step or have already passed through at some earlier
time-step. As a result there are two positions we can transition from.</p>

<figure class="figure-math" style="width:100%;margin-top:10px;margin-bottom:15px;">
  <div style="max-width:590px;display:grid;grid-template-columns:10% 40% 40%;grid-column-gap:5%">
  <div>
    <d-math>\alpha_{s, t} \; =</d-math>
  </div>
  <div>
    <d-math>(\alpha_{s-1, t-1} + \alpha_{s, t-1}) \quad\quad \cdot</d-math>
    <figcaption style="padding-top:10px">
    The CTC probability of the two valid subsequences after
    <d-math>t-1</d-math> input steps.
    </figcaption>
  </div>
  <div>
    <d-math>p_t(z_{s} \mid X)</d-math>
    <figcaption style="padding-top:10px">
    The probability of the current character at input step <d-math>t.</d-math>
    </figcaption>
  </div>
</figure>


<div>

<figure style="width:150px;float:right;margin-top:20px;margin-bottom:0px;margin-left:15%;">
  <img src="assets/cost_regular.svg" />
</figure>

<p><strong>Case 2:</strong></p>

<p>In the second case, we're allowed to skip the previous token in
<d-math>Z.</d-math> We have this case whenever <d-math>z_{s-1}</d-math> is
an <d-math>\epsilon</d-math> between unique characters. As a result there are
three positions we could have come from at the previous step.</p>
</div>

<figure class="figure-math" style="width:100%;margin-top:10px;margin-bottom:15px;">
  <div style="max-width:600px;display:grid;grid-template-columns:10% 50% 30%;grid-column-gap:5%">
  <div>
    <d-math>\alpha_{s, t} \; =</d-math>
  </div>
  <div>
    <d-math>(\alpha_{s-2, t-1} + \alpha_{s-1, t-1} + \alpha_{s, t-1}) \quad\quad \cdot</d-math>
    <figcaption style="padding-top:10px">
    The CTC probability of the three valid subsequences after
    <d-math>t-1</d-math> input steps.
    </figcaption>
  </div>
  <div>
    <d-math>p_t(z_{s} \mid X)</d-math>
    <figcaption style="padding-top:10px">
    The probability of the current character at input step <d-math>t.</d-math>
    </figcaption>
  </div>
</figure>

<p>Below is an example of the computation performed by the dynamic programming
algorithm. Every valid alignment has a path in this graph.</p>

<figure style="width:100%;margin-top:0px;margin-bottom:50px;">
<figcaption style="position:absolute; left:0px; top:100px;">
  output<br />
  <d-math>Y =</d-math> [a, b]
</figcaption>
<figcaption style="position:absolute; left:170px; top: 0px;">
  input, <d-math>X</d-math>
</figcaption>
<div style="position:relative;left:80px;top:30px;" >
<img src="assets/ctc_cost.svg" style="width:85%"/>
<figcaption style="max-width:350px;width:85%;">
Node <d-math>(s, t)</d-math> in the diagram represents
<d-math>\alpha_{s, t}</d-math> – the CTC score of
the subsequence <d-math>Z_{1:s}</d-math> after
<d-math>t</d-math> input steps.
</figcaption>
</div>
</figure>

<p>There are two valid starting nodes and two valid final nodes since the
<d-math>\epsilon</d-math> at the beginning and end of the sequence is
optional. The complete probability is the sum of the two final nodes.</p>

<p>Now that we can efficiently compute the loss function, the next step is to
compute a gradient and train the model. The CTC loss function is differentiable
with respect to the per time-step output probabilities since it's just sums and
products of them. Given this, we can analytically compute the gradient of the
loss function with respect to the (unnormalized) output probabilities and from
there run backpropagation as usual.</p>

<p>For a training set <d-math>\mathcal{D}</d-math>, the model's parameters
are tuned to minimize the negative log-likelihood
<d-math block>
\sum_{(X, Y) \in \mathcal{D}} -\log\; p(Y \mid X)
</d-math>
instead of maximizing the likelihood directly.</p>

<h3 id="inference">Inference</h3>

<p>After we've trained the model, we'd like to use it to find a likely output
for a given input. More precisely, we need to solve
<d-math block>
Y^* \enspace = \enspace {\mathop{\text{argmax}}\limits_{Y}} \enspace p(Y \mid X).
</d-math>
</p>

<p>One heuristic is to take the most likely output at each time-step. This
gives us the alignment with the highest probability:</p>

<d-math block>
A^* \enspace = \enspace {\mathop{\text{argmax}}\limits_{A}} \enspace  \prod_{t=1}^{T} \; p_t(a_t \mid X)
</d-math>

<p>We can then collapse repeats and remove <d-math>\epsilon</d-math> tokens to
get <d-math>Y.</d-math></p>

<p>For many applications this heuristic works well, especially when most of the
probability mass is alloted to a single alignment. However, this approach can
sometimes miss easy to find outputs with much higher probability. The problem
is, it doesn't take into account the fact that a single output can have many
alignments.</p>

<p>Here's an example. Assume the alignments [a, a, <d-math>\epsilon</d-math>]
and [a, a, a] individually have lower probability than [b, b, b]. But 
the sum of their probabilities is actually greater than that of [b, b, b]. The
naive heuristic will incorrectly propose <d-math>Y =</d-math> [b] as
the most likely hypothesis. It should have chosen <d-math>Y =</d-math> [a].
To fix this, the algorithm needs to account for the fact that [a, a, a] and [a,
a, <d-math>\epsilon</d-math>] collapse to the same output.</p>

<p>We can use a modified beam search to solve this. Given limited
computation, the modified beam search won't necessarily find the
most likely <d-math>Y.</d-math> It does, at least, have
the nice property that we can trade-off more computation
(a larger beam-size) for an asymptotically better solution.</p>

<p>A regular beam search computes a new set of hypotheses at each input step.
The new set of hypotheses is generated from the previous set by extending each
hypothesis with all possible output characters and keeping only the top
candidates.</p>

<figure style="grid-column:page; width:100%; max-width:704px; margin-top:0px; margin-bottom:10px;">
  <img src="assets/beam_search.svg" style="width:100%" />
  <figcaption style="width:300px;">
  A standard beam search algorithm with an alphabet of
  <d-math>\{\epsilon, a, b\}</d-math> and a beam size
  of three.
  </figcaption>
</figure>

<p>We can modify the vanilla beam search to handle multiple alignments mapping to
the same output. In this case instead of keeping a list of alignments in the
beam, we store the output prefixes after collapsing repeats and removing
<d-math>\epsilon</d-math> characters. At each step of the search we accumulate
scores for a given prefix based on all the alignments which map to it.</p>

<figure style="grid-column:page; width:100%; max-width:900px; margin-top:0px; margin-bottom:10px;">
  <object data="assets/prefix_beam_search.svg" type="image/svg+xml" style="width:100%"></object>
  <figcaption style="width:300px;">
  The CTC beam search algorithm with an output alphabet
  <d-math>\{\epsilon, a, b\}</d-math>
  and a beam size of three.
  </figcaption>
</figure>

<p>A proposed extension can map to two output prefixes if the character is a
repeat. This is shown at <d-math>T=3</d-math> in the figure above
where ‘a’ is proposed as an extension to the prefix [a]. Both [a] and [a, a] are
valid outputs for this proposed extension.</p>

<p>When we extend [a] to produce [a,a], we only want include the part of the
previous score for alignments which end in <d-math>\epsilon.</d-math> Remember, the
<d-math>\epsilon</d-math> is required between repeat characters. Similarly,
when we don’t extend the prefix and produce [a], we should only include the part
of the previous score for alignments which don’t end in <d-math>\epsilon.</d-math></p>

<p>Given this, we have to keep track of two probabilities for each prefix
in the beam. The probability of all alignments which end in
<d-math>\epsilon</d-math> and the probability of all alignments which don’t
end in <d-math>\epsilon.</d-math> When we rank the hypotheses at
each step before pruning the beam, we'll use their combined scores.</p>

<figure style="grid-column:page; width:100%; max-width:900px; margin-top:0px; margin-bottom:0px;">
  <object data="assets/prefix_beam_search_single.svg" type="image/svg+xml" style="width:100%"></object>
</figure>

<p>The implementation of this algorithm doesn't require much code, but it is
dense and tricky to get right. Checkout this <a href="https://gist.github.com/awni/56369a90d03953e370f3964c826ed4b0">gist</a> for an example implementation in Python.</p>

<p>In some problems, such as speech recognition, incorporating a language model
over the outputs significantly improves accuracy. We can include the language
model as a factor in the inference problem.</p>

<figure class="figure-math" style="width:100%;margin-top:0px;margin-bottom:15px;">
  <div style="max-width:570px;display:grid;grid-auto-flow:column;grid-auto-columns:auto;grid-column-gap:5%">
    <div>
      <d-math>Y^* \enspace = \enspace {\mathop{\text{argmax}}\limits_{Y}} <d-math>
    </div>
    <div>
      <d-math>p(Y \mid X) \quad \cdot</d-math>
      <figcaption style="padding-top:1vw">
      The&nbsp;CTC conditional probability.
      </figcaption>
    </div>
    <div>
      <d-math>p(Y)^\alpha \quad \cdot</d-math>
      <figcaption style="padding-top:1vw;">
      The&nbsp;language model probability.
      </figcaption>
    </div>
    <div>
      <d-math>L(Y)^\beta</d-math>
      <figcaption style="padding-top:1vw">
      The&nbsp;"word" insertion bonus.
      </figcaption>
    </div>
  </div>
</figure>

<p>The function <d-math>L(Y)</d-math> computes the length of
<d-math>Y</d-math> in terms of the language model tokens and acts as a word
insertion bonus. With a word-based language model <d-math>L(Y)</d-math>
counts the number of words in <d-math>Y.</d-math> If we use a character-based
language model then <d-math>L(Y)</d-math> counts the number of characters
in <d-math>Y.</d-math> The language model scores are only included when a
prefix is extended by a character (or word) and not at every step of the
algorithm. This causes the search to favor shorter prefixes, as measured by
<d-math>L(Y)</d-math>, since they don't include as many language model
updates. The word insertion bonus helps with this. The parameters
<d-math>\alpha</d-math> and <d-math>\beta</d-math> are usually set by
cross-validation.</p>

<p>The language model scores and word insertion term can be included in the
beam search. Whenever we propose to extend a prefix by a character, we can
include the language model score for the new character given the prefix so
far.</p>

<hr />
<h2 id="properties-of-ctc">Properties of CTC</h2>

<p>We mentioned a few important properties of CTC so far. Here we’ll go
into more depth on what these properties are and what trade-offs they offer.</p>

<h3 id="conditional-independence">Conditional Independence</h3>

<p>One of the most commonly cited shortcomings of CTC is the conditional
independence assumption it makes.
<div>
<figure style="max-width:200px;float:right;margin-top:0px;margin-bottom:10px;margin-left:10%;margin-right:10%;">
  <img src="assets/conditional_independence.svg" style="width:90%" />
  <figcaption>
  Graphical model for CTC.
  </figcaption>
</figure>
<p>The model assumes that every output is conditionally independent of
the other outputs given the input. This is a bad assumption for many
sequence to sequence problems.</p>
</div>

<p>Say we had an audio clip of someone saying “triple A”.
<d-cite key="Chan2016las"></d-cite> Another valid transcription could
be “AAA”. If the first letter of the predicted transcription is ‘A’, then
the next letter should be ‘A’ with high probability and 'r' with low
probability. The conditional independence assumption does not allow for this.</p>

<figure style="width:100%;margin-top:0px;margin-bottom:20px;">
  <div style="max-width:600px;margin-left:auto;margin-right:auto;">
  <img src="assets/triple_a.svg" style="width:100%;"/>
  <figcaption style="max-width:500px;padding-top:1em;">
  If we predict an 'A' as the first letter then the suffix 'AA' should get much
  more probability than 'riple A'. If we predict 't' first, the opposite
  should be true.
  </figcaption>
  </div>
</figure>

<p>In fact speech recognizers using CTC don't learn a language model over the
output nearly as well as models which are conditionally dependent.
<d-cite key="Battenberg2017"></d-cite> However, a separate language model can
be included and usually gives a good boost to accuracy.</p>

<p>The conditional independence assumption made by CTC isn't always a bad
thing. Baking in strong beliefs over output interactions makes the model less
adaptable to new or altered domains. For example, we might want to use a speech
recognizer trained on phone conversations between friends to transcribe
customer support calls. The language in the two domains can be quite different
even if the acoustic model is similar. With a CTC acoustic model, we can easily
swap in a new language model as we change domains.</p>

<h3 id="alignment-properties">Alignment Properties</h3>

<p>The CTC algorithm is <em>alignment-free</em>. The objective function
marginalizes over all alignments. While CTC does make strong assumptions about
the form of alignments between <d-math>X</d-math> and <d-math>Y</d-math>, the
model is agnostic as to how probability is distributed amongst them. In some
problems CTC ends up allocating most of the probability to a single alignment.
However, this isn't guaranteed. We can force the model to choose a single
alignment by replacing the sum with a max in the objective function,
<d-math block>
p(Y \mid X) \enspace = \enspace \max_{A \in \mathcal{A}_{X,Y}} \enspace \prod_{t=1}^T \; p(a_t \mid X).
</d-math></p>

<p>As mentioned before, CTC only allows <em>monotonic</em> alignments. In
problems such as speech recognition this may be a valid assumption. For other
problems like machine translation where a future word in a target sentence
can align to an earlier part of the source sentence, this assumption is a
deal-breaker.</p>

<p>Another important property of CTC alignments is that they are
<em>many-to-one</em>. Multiple inputs can align to at most one output. In some
cases this may not be desirable. We might want to enforce a strict one-to-one
correspondence between elements of <d-math>X</d-math> and
<d-math>Y.</d-math> Alternatively, we may want to allow multiple output
elements to align to a single input element. For example, the characters
“th” might align to a single input step of audio. A character based CTC model
would not allow that.</p>

<p>The many-to-one property implies that the output can't have more time-steps
than the input.
<d-footnote>
  If <d-math>Y</d-math> has <d-math>r</d-math> consecutive
  repeats, then the length of <d-math>Y</d-math> must be less than
  the length of <d-math>X</d-math> by <d-math>2r - 1.</d-math>
</d-footnote>
This is usually not a problem for speech and handwriting recognition since the
input is much longer than the output. However, for other problems where
<d-math>Y</d-math> is often longer than <d-math>X</d-math>, CTC just won't
work.</p>

<hr />

<h2 id="ctc-in-context">CTC in Context</h2>

<p>In this section we’ll discuss how CTC relates to other commonly used
algorithms for sequence modeling.</p>

<h3 id="hmms">HMMs</h3>

<p>At a first glance, a Hidden Markov Model (HMM) seems quite different from
CTC. But, the two algorithms are actually quite similar. Understanding the
relationship between them will help us understand what advantages CTC has over
HMM sequence models and give us insight into how CTC could be changed for
various use cases.</p>

<p style="margin-bottom:0px">Let's use the same notation as before,
<d-math>X</d-math> is the input sequence and <d-math>Y</d-math>
is the output sequence with lengths <d-math>T</d-math> and
<d-math>U</d-math> respectively. We're interested in learning
<d-math>p(Y \mid X).</d-math> One way to simplify the problem is to apply
Bayes' Rule:
<d-math block>
p(Y \mid X) \; \propto \; p(X \mid Y) \; p(Y).
</d-math>

The <d-math>p(Y)</d-math> term can be any language model, so let's focus on
<d-math>p(X \mid Y).</d-math> Like before we'll let
<d-math>\mathcal{A}</d-math> be a set of allowed of alignments between
<d-math>X</d-math> and <d-math>Y.</d-math> Members of
<d-math>\mathcal{A}</d-math> have length <d-math>T.</d-math>
Let’s otherwise leave <d-math>\mathcal{A}</d-math> unspecified for now. We'll
come back to it later. We can marginalize over alignments to get
<d-math block>
p(X \mid Y)\; = \; \sum_{A \in \mathcal{A}} \; p(X, A \mid Y).
</d-math>
To simplify notation, let's remove the conditioning on <d-math>Y</d-math>, it
will be present in every <d-math>p(\cdot).</d-math> With two assumptions we can
write down the standard HMM.</p>

<figure class="figure-math" style="width:100%;margin-top:10px;margin-bottom:15px;">
  <div style="max-width:530px;display:grid;grid-auto-flow:column;grid-auto-columns:auto;grid-column-gap:5%">
    <div>
      <d-math>p(X) \quad =</d-math>
      <figcaption style="padding-top:10px">
        The probability of the <em>input</em>
      </figcaption>
    </div>
    <div>
      <d-math>\sum_{A \in \mathcal{A}} \; \prod_{t=1}^T</d-math>
      <figcaption style="padding-top:10px">
        marginalizes over alignments
      </figcaption>
    </div>
    <div>
      <d-math>p(x_t \mid a_t) \quad \cdot</d-math>
      <figcaption style="padding-top:10px">
        the emission probability
      </figcaption>
    </div>
    <div>
      <d-math>p(a_t \mid a_{t-1})</d-math>
      <figcaption style="padding-top:10px">
        and the transition probability.
      </figcaption>
    </div>
  </div>
</figure>

<p>The first assumption is the usual Markov property. The state
<d-math>a_t</d-math> is conditionally independent of all historic states given
the previous state <d-math>a_{t-1}.</d-math> The second is that the observation
<d-math>x_t</d-math> is conditionally independent of everything given the
current state <d-math>a_t.</d-math></p>

<figure style="width:300px;margin-top:0px;margin-bottom:10px;">
  <img src="assets/hmm.svg" />
  <figcaption> 
  The graphical model for an HMM.
  </figcaption>
</figure>

<p>Now we can take just a few steps to transform the HMM into CTC and see how
the two models relate. First, let's assume that the transition probabilities
<d-math>p(a_t \mid a_{t-1})</d-math> are uniform. This gives
<d-math block>
p(X) \enspace \propto \enspace \sum_{A \in \mathcal{A}} \enspace \prod_{t=1}^T \; p(x_t \mid a_t).
</d-math>
There are only two differences from this equation and the CTC loss function.
The first is that we are learning a model of <d-math>X</d-math> given
<d-math>Y</d-math> as opposed to <d-math>Y</d-math> given <d-math>X.</d-math>
The second is how the set <d-math>\mathcal{A}</d-math> is produced. Let’s deal
with each in turn.</p>

<p>The HMM can be used with discriminative models which estimate <d-math>p(a \mid x).</d-math>
To do this, we apply Bayes’ rule and rewrite the model as 
<d-math block>
p(X) \enspace \propto \enspace \sum_{A \in \mathcal{A}} \enspace \prod_{t=1}^T \; \frac{p(a_t \mid x_t)\; p(x_t)}{p(a_t)}
</d-math>
<d-math block> <!-- For some reason second line fraction bar doesn't show up in aligned environment... -->
\quad\quad\quad\propto \enspace \sum_{A \in \mathcal{A}} \enspace \prod_{t=1}^T \; \frac{p(a_t \mid x_t)}{p(a_t)}. 
</d-math>
</p>

<p>If we assume a uniform prior over the states <d-math>a</d-math> and condition on all of
<d-math>X</d-math> instead of a single element at a time, we arrive at 
<d-math block>
p(X) \enspace \propto \enspace \sum_{A \in \mathcal{A}} \enspace \prod_{t=1}^T \; p(a_t \mid X). 
</d-math></p>

<p>The above equation is essentially the CTC loss function, assuming the set
<d-math>\mathcal{A}</d-math> is the same. In fact, the HMM framework does not specify what
<d-math>\mathcal{A}</d-math> should consist of. This part of the model can be designed on a
per-problem basis. In many cases the model doesn't condition on <d-math>Y</d-math> and the
set <d-math>\mathcal{A}</d-math> consists of all possible length <d-math>T</d-math> sequences from the
output alphabet. In this case, the HMM can be drawn as an  <em>ergodic</em> state
transition diagram in which every state connects to every other state.  The
figure below shows this model with the alphabet or set of unique hidden states
as <d-math>\{a, b, c\}.</d-math></p>

<p>In our case the transitions allowed by the model are strongly related to
<d-math>Y.</d-math> We want the HMM to reflect this. One possible model could
be a simple linear state transition diagram. The figure below shows this with
the same alphabet as before and <d-math>Y =</d-math> [a, b]. Another commonly
used model is the <em>Bakis</em> or left-right HMM. In this model any
transition which proceeds from the left to the right is allowed.</p>

<figure class="hmm-grid" style="width:100%;margin-top:0px;">
  <div>
    <img src="assets/ergodic_hmm.svg"/>
    <figcaption>
    <strong>Ergodic HMM:</strong> Any node can be either a starting or
    final state.
    </figcaption>
  </div>
  <div>
    <img src="assets/linear_hmm.svg"/>
    <figcaption>
    <strong>Linear HMM:</strong> Start on the left, end on the right. 
    </figcaption>
  </div>
  <div>
    <img src="assets/ctc_hmm.svg" />
    <figcaption style="max-width:250px;">
    <strong>CTC HMM:</strong> The first two nodes are the starting
    states and the last two nodes are the final states.
    </figcaption>
  </div>
</figure>

<p>In CTC we augment the alphabet with <d-math>\epsilon</d-math> and the HMM model allows a
subset of the left-right transitions. The CTC HMM has two start
states and two accepting states.</p>

<p>One possible source of confusion is that the HMM model differs for any unique
<d-math>Y.</d-math> This is in fact standard in applications such as speech recognition. The
state diagram changes based on the output <d-math>Y.</d-math> However, the functions which
estimate the observation and transition probabilities are shared.</p>

<p>Let’s discuss how CTC improves on the original HMM model. First, we can think
of the CTC state diagram as a special case HMM which works well for many
problems of interest. Incorporating the blank as a hidden state in the HMM
allows us to use the alphabet of <d-math>Y</d-math> as the other hidden states. This model
also gives a set of allowed alignments which may be a good prior for some
problems.</p>

<p>Perhaps most importantly, CTC is discriminative. It models <d-math>p(Y \mid
  X)</d-math> directly, an idea that's been important in the past with other
discriminative improvements to HMMs.<d-cite key="Woodland2002"></d-cite>
Discriminative training let's us apply powerful learning algorithms like the
RNN directly towards solving the problem we care about.</p>

<h3 id="encoder-decoder-models">Encoder-Decoder Models</h3>

<p>The encoder-decoder is perhaps the most commonly used framework for sequence
transduction with neural networks. This class of models consists of an encoder
and a decoder. The encoder maps the input sequence <d-math>X</d-math> into a
hidden representation. The decoder consumes the hidden representation and
produces a distribution over the outputs. We can write this as

<d-math block>
\begin{aligned}
H\enspace &= \enspace\textsf{encode}(X) \\[.5em]
p(Y \mid X)\enspace &= \enspace \textsf{decode}(H).
\end{aligned}
</d-math>

The <d-math>\textsf{encode}(\cdot)</d-math> and
<d-math>\textsf{decode}(\cdot)</d-math> functions are typically RNNs.  The
decoder can optionally be equipped with an attention mechanism. The hidden
state sequence <d-math>H</d-math> has the same number of time-steps as the
input, <d-math>T.</d-math> Sometimes the encoder subsamples the input. If the
encoder subsamples the input by a factor <d-math>s</d-math> then
<d-math>H</d-math> will have <d-math>T/s</d-math> time-steps.</p>

<p>We can interpret CTC in the encoder-decoder framework. This is helpful to
understand the developments in encoder-decoder models that are applicable to
CTC and to develop a common language for the properties of these
models.</p>

<p><strong>Encoder:</strong> The encoder of a CTC model can be just about any
encoder we find in commonly used encoder-decoder models. For example the
encoder could be a multi-layer bidirectional RNN or a convolutional network.
There is a constraint on the CTC encoder that doesn't apply to the others. The
input length cannot be sub-sampled so much that <d-math>T/s</d-math>
is less than <d-math>U.</d-math></p>

<p><strong>Decoder:</strong> We can view the decoder of a CTC model as a simple
linear transformation followed by a softmax normalization. This layer should
project all <d-math>T</d-math> steps of the encoder output
<d-math>H</d-math> into the dimensionality of the output alphabet.</p>

<p>We mentioned earlier that CTC makes a conditional independence assumption over
the characters in the output sequence. This is one of the big advantages that
other encoder-decoder models have over CTC &mdash; they can model the
dependence over the outputs. However in practice, CTC is still more commonly
used in tasks like Speech Recognition as we can partially overcome the
conditional independence assumption by including an external language model.</p>

<hr />
<h2 id="practitioners-guide">Practitioner’s Guide</h2>

<p>So far we've mostly developed a conceptual understanding of CTC. Here we’ll go
through a few implementation tips for practitioners.</p>

<p><strong>Software:</strong> Even with a solid understanding of CTC, the
implementation is difficult. The algorithm has several edge cases and a fast
implementation should be written in a lower-level programming language.
Open-source software tools make it much easier to get started:</p>

<ul>
  <li>Baidu Research has open-sourced
    <a href="https://github.com/baidu-research/warp-ctc">warp-ctc</a>. The
    package is written in C++ and CUDA. The CTC loss function runs on either
    the CPU or the GPU. Bindings are available for Torch, TensorFlow and
    <a href="https://github.com/awni/warp-ctc">PyTorch</a>.
  </li>
  <li>TensorFlow has built in
    <a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_loss">CTC loss</a>
    and <a href="https://www.tensorflow.org/api_docs/python/tf/nn/ctc_beam_search_decoder">CTC beam search</a>
    functions for the CPU.
  </li>
  <li>Nvidia also provides a GPU implementation of CTC in
    <a href="https://developer.nvidia.com/cudnn">cuDNN</a> versions 7 and up.
  </li>
</ul>

<p><strong>Numerical Stability:</strong> Computing the CTC loss naively is
numerically unstable. One method to avoid this is to normalize the
<d-math>\alpha</d-math>’s at each time-step. The original publication
has more detail on this including the adjustments to the gradient.
<d-cite key="Graves2006"></d-cite> In practice this works well enough
for medium length sequences but can still underflow for long sequences.
A better solution is to compute the loss function in log-space with the
log-sum-exp trick
<d-footnote>
When computing the sum of two probabilities in log space use the identity
<d-math block>
\log(e^a + e^b) = \max\{a, b\} + \log(1 + e^{-|a-b|})
</d-math>
Most programming languages have a stable function to compute
<d-math>\log(1 + x)</d-math> when
<d-math>x</d-math> is close to zero.
</d-footnote>.

Inference should also be done in log-space using the log-sum-exp trick.</p>

<p><strong>Beam Search:</strong> There are a couple of good tips to know about when
implementing  and using the CTC beam search.</p>

<p>The correctness of the beam search can be tested as follows.</p>
<ol>
  <li>Run the beam search algorithm on an arbitrary input.</li>
  <li>Save the inferred output <d-math>\bar{Y}</d-math> and the corresponding score <d-math>\bar{c}.</d-math></li>
  <li>Compute the actual CTC score <d-math>c</d-math> for <d-math>\bar{Y}</d-math> using the same input.</li>
  <li>Check that <d-math>\bar{c} \approx c</d-math> with the former being no greater than the later.
As the beam size increases the inferred output <d-math>\bar{Y}</d-math> may change, but the two
numbers should grow closer.</li>
</ol>

<p>A common question when using a beam search decoder is the size of the beam
to use.  There is a trade-off between accuracy and runtime. We can check if the
beam size is in a good range. To do this first compute the CTC score for the
inferred output <d-math>c_i.</d-math> Then compute the CTC score for the ground
truth output <d-math>c_g.</d-math> If the two outputs are not the same, we
should have <d-math>c_g \lt c_i.</d-math> If <d-math>c_i << c_g</d-math> then
the ground truth output actually has a higher probability under the model and
the beam search failed to find it. In this case a large increase to the beam
size may be warranted.</p>

<hr />
<h2 class="no_toc" id="bibliographic-notes">Bibliographic Notes</h2>

<p>The CTC algorithm was first published by Graves et al. in 2006.
<d-cite key="Graves2006"></d-cite> The first experiments were on TIMIT,
a popular phoneme recognition benchmark.<d-cite key="Lopes2011"></d-cite>
Chapter 7 of Graves’ thesis<d-cite key="Graves2012"></d-cite> also gives a
detailed treatment of CTC.</p>

<p>One of the first applications of CTC to large vocabulary speech recognition was
by Graves et al. in 2014.<d-cite key="Graves2014"></d-cite>
They combined a hybrid DNN-HMM and a CTC trained model to achieve state-of-the-art results.
Hannun et al. subsequently demonstrated state-of-the-art CTC based speech
recognition on larger benchmarks.<d-cite key="Hannun2014deepspeech"></d-cite>
A CTC model outperformed other methods on an online handwriting
recognition benchmark in 2007.<d-cite key="Liwicki2007"></d-cite></p>

<p>CTC has been used successfully in many other problems. Some examples are
lip-reading from video<d-cite key="Assael2016"></d-cite>, action recognition from
video<d-cite key="Huang2016"></d-cite> and keyword detection in audio.
<d-cite key="Fernandez2007,Lengerich2016"></d-cite></p>

<p>Many extensions and improvements to CTC have been proposed. Here are a few.
The <em>Sequence Transducer</em> discards the conditional independence assumption
made by CTC.<d-cite key="Graves2012transducer"></d-cite> As a consequence, the
model allows the output to be longer than the input. The <em>Gram-CTC</em> model
generalizes CTC to marginalize over n-gram output classes.
<d-cite key="Liu2017"></d-cite> Other works have generalized CTC or proposed
similar algorithms to account for segmental structure in the output.
<d-cite key="Wang2017,Kong2016"></d-cite></p>

<p>The Hidden Markov Model was developed in the 1960’s with the first application
to speech recognition in the 1970’s. For an introduction to the HMM and
applications to speech recognition see Rabiner's canonical tutorial.
<d-cite key="Rabiner1989"></d-cite></p>

<p>Encoder-decoder models were developed in 2014.
<d-cite key="Cho2014,Sutskever2014"></d-cite> <em>Distill</em> has an
in-depth guide to attention in encoder-decoder
models.<d-cite key="Olah2016"></d-cite></p>

</d-article>
<d-appendix>
  <h3 id="acknowledgements">Acknowledgments</h3>
  <p>I'm especially grateful to the Distill team for <em>dramatically</em>
  improving the quality of this article. Thanks to Chris Olah's suggestions and
  feedback, both the written and visual content of the article are
  substantially better. Thanks to Shan Carter for substantial improvements to
  the figures, and thanks to Ludwig Schubert for help with the Distill
  template.</p>

  <p>Thanks to Sanjeev Satheesh, Chris Lengerich, Dan Jurafsky and the
  anonymous reviewers for their feedback. I'm also very grateful to Andrew Ng
  for feedback on the article and his support.</p>
  <h3 id="discussion-review">Discussion and Review</h3>
  <p>
    <a href="https://github.com/distillpub/post--ctc/issues/13">Review-1 Anonymous</a><br />
    <a href="https://github.com/distillpub/post--ctc/issues/14">Review-2 Anonymous</a>
  </p>

  <d-footnote-list></d-footnote-list>
  <d-bibliography>
    <script type="text/bibtex">
      @article{Battenberg2017,
      archivePrefix = {arXiv},
      arxivId = {1707.07413},
      author = {Battenberg, Eric and Chen, Jitong and Child, Rewon and Coates, Adam and Gaur, Yashesh and Li, Yi and Liu, Hairong and Satheesh, Sanjeev and Seetapun, David and Sriram, Anuroop and Zhu, Zhenyao},
      eprint = {1707.07413},
      month = {jul},
      title = {Exploring Neural Transducers for End-to-End Speech Recognition},
      url = {http://arxiv.org/abs/1707.07413},
      year = {2017}
      }
      @article{Olah2016,
      author = {Olah, C and Carter, S},
      journal = {Distill},
      title = {Attention and augmented recurrent neural networks},
      url = {http://distill.pub/2016/augmented-rnns/},
      year = {2016}
      }
      @article{Sutskever2014,
      archivePrefix = {arXiv},
      arxivId = {1409.3215},
      author = {Sutskever, Ilya and Vinyals, Oriol and Le, Quoc V.},
      eprint = {1409.3215},
      journal = {Advances in neural information processing systems},
      month = {sep},
      title = {Sequence to Sequence Learning with Neural Networks},
      url = {http://arxiv.org/abs/1409.3215},
      year = {2014}
      }
      @article{Cho2014,
      archivePrefix = {arXiv},
      arxivId = {1406.1078},
      author = {Cho, Kyunghyun and van Merrienboer, Bart and Gulcehre, Caglar and Bahdanau, Dzmitry and Bougares, Fethi and Schwenk, Holger and Bengio, Yoshua},
      doi = {10.3115/v1/D14-1179},
      eprint = {1406.1078},
      isbn = {9781937284961},
      issn = {09205691},
      journal = {EMNLP},
      pmid = {2079951},
      title = {Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation},
      url = {https://arxiv.org/abs/1406.1078},
      year = {2014}
      }
      @article{Rabiner1989,
      author = {Rabiner, L.R. R.},
      doi = {10.1109/5.18626},
      isbn = {0018-9219},
      issn = {00189219},
      journal = {Proceedings of the IEEE},
      number = {2},
      pages = {p257--286},
      title = {Tutorial on Hidden Markov Models and Selected Applications in Speech Recognition},
      url = {http://ieeexplore.ieee.org/abstract/document/18626/},
      volume = {77},
      year = {1989}
      }
      @inproceedings{Liwicki2007,
      author = {Liwicki, Marcus and Graves, Alex and Bunke, Horst and Schmidhuber, Jürgen},
      booktitle = {Proceedings - 9th Int. Conf. on Document Analysis and Recognition},
      doi = {10.1.1.139.5852},
      pages = {367--371},
      title = {A novel approach to on-line handwriting recognition based on bidirectional long short-term memory networks},
      url = {https://www.cs.toronto.edu/~graves/icdar_2007.pdf},
      volume = {1},
      year = {2007}
      }
      @book{Graves2012,
      archivePrefix = {arXiv},
      arxivId = {arXiv:1308.0850v1},
      author = {Graves, Alex},
      booktitle = {Springer},
      doi = {10.1007/978-3-642-24797-2},
      eprint = {arXiv:1308.0850v1},
      isbn = {978-3-642-24796-5},
      issn = {01406736},
      pmid = {7491034},
      title = {Supervised Sequence Labelling with Recurrent Neural Networks},
      url = {http://link.springer.com/10.1007/978-3-642-24797-2},
      volume = {385},
      year = {2012}
      }
      @article{Lopes2011,
      author = {Lopes, Carla and Perdigão, Fernando},
      doi = {10.5772/17600},
      isbn = {978-953-307-996-7},
      issn = {9789533070865},
      journal = {Speech Technologies},
      pages = {285--302},
      title = {Phone recognition on the TIMIT database},
      url = {https://www.intechopen.com/books/speech-technologies/phoneme-recognition-on-the-timit-database/},
      volume = {1},
      year = {2011}
      }
      @article{Graves2014,
      archivePrefix = {arXiv},
      arxivId = {1512.02595},
      author = {Graves, Alex and Jaitly, Navdeep},
      doi = {10.1145/1143844.1143891},
      eprint = {1512.02595},
      isbn = {1595933832},
      issn = {10987576},
      journal = {Proceedings of the 31st International Conference on Machine Learning (ICML-14)},
      month = {jan},
      number = {1},
      pages = {1764--1772},
      pmid = {1000285842},
      title = {Towards End-To-End Speech Recognition with Recurrent Neural Networks},
      url = {http://jmlr.org/proceedings/papers/v32/graves14.pdf},
      volume = {32},
      year = {2014}
      }
      @article{Graves2006,
      archivePrefix = {arXiv},
      arxivId = {1512.02595},
      author = {Graves, Alex and Fernandez, Santiago and Gomez, Faustino and Schmidhuber, Jürgen},
      doi = {10.1145/1143844.1143891},
      eprint = {1512.02595},
      isbn = {1595933832},
      issn = {10987576},
      journal = {Proceedings of the 23rd international conference on Machine Learning},
      pages = {369--376},
      pmid = {1000285842},
      title = {Connectionist Temporal Classification : Labelling Unsegmented Sequence Data with Recurrent Neural Networks},
      url = {ftp://ftp.idsia.ch/pub/juergen/icml2006.pdf},
      year = {2006}
      }
      @inproceedings{Chan2016las,
      author = {Chan, William and Jaitly, Navdeep and Le, Quoc V and Vinyals, Oriol},
      booktitle = {ICASSP},
      title = {Listen, Attend and Spell: A Neural Network for Large Vocabulary Conversational Speech Recognition},
      url = {https://arxiv.org/abs/1508.01211},
      year = {2016}
      }
      @article{Hannun2014deepspeech,
      author = {Hannun, Awni Y and Case, Carl and Casper, Jared and Catanzaro, Bryan and Diamos, Greg and Elsen, Erich and Prenger, Ryan and Satheesh, Sanjeev and Sengupta, Shubho and Coates, Adam and Ng, Andrew Y},
      title = {Deep Speech: Scaling up end-to-end speech recognition},
      url = {http://arxiv.org/abs/1412.5567},
      volume = {abs/1412.5},
      year = {2014}
      }
      @article{Huang2016,
      archivePrefix = {arXiv},
      arxivId = {1607.08584},
      author = {Huang, De-An and Fei-Fei, Li and Niebles, Juan Carlos},
      doi = {10.1007/978-3-319-46493-0},
      eprint = {1607.08584},
      isbn = {9783319464930},
      issn = {0302-9743},
      journal = {European Conference on Computer Vision},
      month = {jul},
      pages = {137--153},
      pmid = {10463930},
      title = {Connectionist Temporal Modeling for Weakly Supervised Action Labeling},
      url = {http://arxiv.org/abs/1607.08584},
      year = {2016}
      }
      @article{Assael2016,
      archivePrefix = {arXiv},
      arxivId = {1611.01599},
      author = {Assael, Yannis M. and Shillingford, Brendan and Whiteson, Shimon and de Freitas, Nando},
      eprint = {1611.01599},
      month = {nov},
      title = {LipNet: End-to-End Sentence-level Lipreading},
      url = {http://arxiv.org/abs/1611.01599},
      year = {2016}
      }
      @article{Lengerich2016,
      archivePrefix = {arXiv},
      arxivId = {1611.09405},
      author = {Lengerich, Chris and Hannun, Awni},
      eprint = {1611.09405},
      journal = {NIPS 2016 End-to-End Learning for Speech and Audio Processing Workshop},
      month = {nov},
      title = {An End-to-End Architecture for Keyword Spotting and Voice Activity Detection},
      url = {http://arxiv.org/abs/1611.09405},
      year = {2016}
      }
      @article{Fernandez2007,
      author = {Fernández, Santiago and Graves, Alex and Schmidhuber, Jürgen},
      doi = {10.1007/978-3-540-74695-9_23},
      isbn = {9783540746935},
      issn = {03029743},
      journal = {The 17th international conference on Artificial neural networks},
      pages = {220--229},
      title = {An application of recurrent neural networks to discriminative keyword spotting},
      url = {http://link.springer.com/10.1007/978-3-540-74695-9_23},
      year = {2007}
      }
      @article{Graves2012transducer,
      archivePrefix = {arXiv},
      arxivId = {1211.3711},
      author = {Graves, Alex},
      doi = {10.1145/2661829.2661935},
      eprint = {1211.3711},
      isbn = {2000201075},
      issn = {18792782},
      pmid = {23459267},
      title = {Sequence Transduction with Recurrent Neural Networks},
      url = {https://arxiv.org/pdf/1211.3711.pdf http://arxiv.org/abs/1211.3711},
      year = {2012}
      }
      @article{Liu2017,
      archivePrefix = {arXiv},
      arxivId = {1703.00096},
      author = {Liu, Hairong and Zhu, Zhenyao and Li, Xiangang and Satheesh, Sanjeev},
      eprint = {1703.00096},
      journal = {Proceedings of the 34th International Conference on Machine Learning},
      month = {feb},
      title = {Gram-CTC: Automatic Unit Selection and Target Decomposition for Sequence Labelling},
      url = {http://arxiv.org/abs/1703.00096},
      year = {2017}
      }
      @article{Wang2017,
      archivePrefix = {arXiv},
      arxivId = {1702.07463},
      author = {Wang, Chong and Wang, Yining and Huang, Po-Sen and Mohamed, Abdelrahman and Zhou, Dengyong and Deng, Li},
      eprint = {1702.07463},
      month = {feb},
      title = {Sequence Modeling via Segmentations},
      url = {http://arxiv.org/abs/1702.07463},
      year = {2017}
      }
      @article{Kong2016,
      archivePrefix = {arXiv},
      arxivId = {1511.06018},
      author = {Kong, Lingpeng and Dyer, Chris and Smith, Noah A.},
      doi = {10.21437/Interspeech.2016-40},
      eprint = {1511.06018},
      journal = {ICLR},
      month = {nov},
      title = {Segmental Recurrent Neural Networks},
      url = {http://arxiv.org/abs/1511.06018},
      year = {2016}
      }
      @article{Woodland2002,
      author = {Woodland, P.C. and Povey, D.},
      doi = {10.1006/csla.2001.0182},
      issn = {08852308},
      journal = {Computer Speech & Language},
      month = {jan},
      number = {1},
      pages = {25--47},
      publisher = {Academic Press},
      title = {Large scale discriminative training of hidden Markov models for speech recognition}}
      url = {https://www.sciencedirect.com/science/article/pii/S0885230801901822},
      volume = {16},
      year = {2002}
      }
    </script>
  </d-bibliography>
</d-appendix>
<distill-footer></distill-footer>
</body>
